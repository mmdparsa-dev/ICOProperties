<!doctype html>
<html lang="fa" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<meta name="color-scheme" content="light dark">
<title>ICOProperties — Beta</title>
<link rel="icon" href="image/favicon.ico" type="image/x-icon">
<link href="https://fonts.googleapis.com/css2?family=Material+Icons+Outlined" rel="stylesheet">
<style>
@font-face {
  font-family: 'Vazir Variable';
  src: url('fonts/Vazir-Variable.woff2') format('woff2'),
       url('fonts/Vazir-Variable.woff') format('woff');
  font-weight: 100 900;
  font-style: normal;
  font-display: swap;
}

/* ---------- theme vars ---------- */
:root{
  --surface: 255 255 255;
  --surface-2: 248 250 253;
  --on-surface: 22 24 35;
  --muted-alpha: 0.68;
  --primary: 16 108 200;
  --primary-variant: 8 70 150;
  --accent: 0 162 255;
  --glass-alpha: 0.78;
  --radius-lg: 14px;
  --spring-duration: 520ms;
  --spring-ease: cubic-bezier(.22,.9,.25,1);
  --shadow-1: 0 6px 18px rgba(16,24,40,0.06);
  --shadow-2: 0 12px 36px rgba(16,24,40,0.08);
  --contrast-low: rgba(0,0,0,0.06);
  --card-bg: 255 255 255;
  --glass-bg: 250 252 255;
  --muted-color: rgba(22,24,35,var(--muted-alpha));
  --hover-max-rot: 9;
  --hover-max-translateZ: 14;
  --hover-shadow-scale: 1.12;

  /* drop zone outline colors (adjusted for visibility) */
  --drop-outline-light: rgba(22,24,35,0.14);   /* stronger in light */
  --drop-outline-drag-light: rgba(16,108,200,0.22);
  --drop-outline-dark: rgba(255,255,255,0.08);
  --drop-outline-drag-dark: rgba(16,108,200,0.22);

  /* frame hover */
  --frame-hover-translateY: -8px;
  --frame-hover-shadow: 0 18px 36px rgba(16,24,40,0.10);
}
body.dark{
  --surface: 20 20 22;
  --surface-2: 28 28 30;
  --on-surface: 235 238 245;
  --muted-alpha: 0.56;
  --glass-alpha: 0.46;
  --shadow-1: 0 6px 18px rgba(0,0,0,0.55);
  --shadow-2: 0 12px 36px rgba(0,0,0,0.55);
  --card-bg: 28 28 30;
  --glass-bg: 30 30 32;
}

/* ---------- base fonts & reset ---------- */
html,body,input,button,select,textarea {
  font-family: 'Vazir Variable', system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial !important;
  -webkit-font-smoothing:antialiased;
  -moz-osx-font-smoothing:grayscale;
}
.material-icons-outlined { font-family: 'Material Icons Outlined' !important; font-style:normal; }

/* ensure full-viewport background (fix white edges in dark mode) */
html{ height:100%; background: rgb(var(--surface)); }
body{ min-height:100vh; margin:0; padding:20px; background: rgb(var(--surface)); color: rgb(var(--on-surface)); -webkit-font-feature-settings: "kern"; transform-style:preserve-3d; }

/* container */
.container{ width:1100px; max-width:calc(100% - 40px); margin:0 auto; background:transparent; }

/* appbar / brand */
header.appbar{ display:flex; align-items:center; justify-content:space-between; gap:16px; margin-bottom:14px; flex-wrap:wrap; }
.brand{ display:flex; align-items:center; gap:12px; }
.logo{ width:56px; height:56px; border-radius:12px; display:grid; place-items:center; background: linear-gradient(135deg, rgba(var(--primary),0.95), rgba(var(--primary-variant),0.95)); color:white; font-weight:700; font-size:18px; box-shadow: 0 8px 30px rgba(13,71,161,0.18); cursor:default; transform-style:preserve-3d; overflow:hidden; }
.title{ font-size:18px; font-weight:700; }
.subtitle{ font-size:12px; color: rgba(var(--on-surface),0.72); }

/* glass surface */
.glass{
  background: linear-gradient(180deg, rgba(var(--glass-bg),1), rgba(var(--card-bg),1));
  border-radius:var(--radius-lg);
  padding:16px;
  box-shadow:var(--shadow-1);
  border: 1px solid rgba(0,0,0,0.04);
  transition: box-shadow var(--spring-duration) var(--spring-ease), transform var(--spring-duration) var(--spring-ease);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
}
body.dark .glass{ background: linear-gradient(180deg, rgba(30,30,30,0.92), rgba(22,22,22,0.96)); border:1px solid rgba(255,255,255,0.03); }

/* uploader layout */
.uploader{ display:flex; gap:16px; align-items:flex-start; flex-wrap:wrap; }
.drop{
  position:relative; flex:1; min-height:150px; border-radius:12px; padding:20px;
  display:flex; flex-direction:column; align-items:center; justify-content:center; gap:10px;
  cursor:pointer;
  background: linear-gradient(180deg, rgba(var(--card-bg),1), rgba(var(--glass-bg),1));
  min-width:0;
  transition: transform var(--spring-duration) var(--spring-ease), box-shadow var(--spring-duration) var(--spring-ease), border-color var(--spring-duration) var(--spring-ease), background-color var(--spring-duration) var(--spring-ease);
  text-align:center; user-select:none; -webkit-user-select:none; transform-style:preserve-3d;
  outline-offset:6px;

  /* use only OUTLINE (single dashed) — remove border dashed */
  outline: 2px dashed var(--drop-outline-light);
  border: none;
  overflow: hidden; /* ensures no child visual escapes */
}
body.dark .drop{
  outline: 2px dashed var(--drop-outline-dark);
  border: none;
}
.drop.dragover{
  outline:3px dashed var(--drop-outline-drag-light);
  box-shadow: 0 12px 30px rgba(16,108,200,0.07);
}
body.dark .drop.dragover{
  outline:3px dashed var(--drop-outline-drag-dark);
  box-shadow: 0 12px 30px rgba(16,108,200,0.08);
}
.drop .big{ font-size:20px; font-weight:700; color: rgb(var(--on-surface)); }
.muted{ color: rgba(var(--on-surface),var(--muted-alpha)); font-size:13px; }
#file{ position:absolute; inset:0; width:100%; height:100%; opacity:0; cursor:pointer; }

/* actions */
.actions{ width:260px; display:flex; flex-direction:column; gap:8px; }
.btn{ display:inline-flex; align-items:center; gap:8px; padding:10px 14px; border-radius:10px; border:none; cursor:pointer; font-weight:700; background:transparent; color:inherit; transition: transform 320ms var(--spring-ease), box-shadow 320ms var(--spring-ease), background-color 320ms var(--spring-ease), color 320ms var(--spring-ease); transform-style:preserve-3d; }
.btn:focus{ outline: 2px solid rgba(var(--primary),0.14); outline-offset:3px; }
.btn.primary{ background: linear-gradient(90deg, rgb(var(--primary)), rgb(var(--primary-variant))); color:#fff; box-shadow: 0 12px 36px rgba(16,108,200,0.16); }
.btn.ghost{ border:1px solid var(--contrast-low); background:transparent; color:inherit; }
.icon{ width:18px; height:18px; display:inline-grid; place-items:center; vertical-align:middle; margin-inline-start:4px; }
.material-icons-outlined.icon{ font-size:18px; }

/* ======================
   === THEME SWITCH (redesign + containment fix)
   ====================== */
.theme-wrapper{ display:inline-flex; align-items:center; }
.theme-switch{ display:inline-flex; align-items:center; gap:8px; position:relative; width:92px; height:40px; padding:6px; border-radius:999px; background: rgba(0,0,0,0.04); cursor:pointer; transition: background-color 320ms var(--spring-ease), box-shadow 320ms var(--spring-ease), border 220ms; border:1px solid rgba(var(--on-surface),0.06); overflow:hidden; }
.theme-switch .track{ position:absolute; inset:6px; border-radius:999px; display:flex; align-items:center; justify-content:space-between; padding:0 10px; pointer-events:none; font-size:12px; color: rgba(var(--on-surface),0.62); }
.theme-switch .icon-sun, .theme-switch .icon-moon { font-size:15px; opacity:0.95; }
.theme-switch .switch-knob{ position:relative; left:0; width:28px; height:28px; border-radius:50%; background: linear-gradient(180deg,#ffffff,#f3f3f3); box-shadow: 0 8px 20px rgba(16,24,40,0.08); transition: transform 300ms var(--spring-ease), background 300ms var(--spring-ease), box-shadow 300ms; transform: translateX(0); z-index:2; display:grid; place-items:center; margin-left:0; }

/* containment: knob movement tuned to track width so it doesn't "escape" */
.theme-switch.theme-on{ background: linear-gradient(90deg, rgb(var(--primary)), rgb(var(--primary-variant))); border-color: rgba(0,0,0,0.04); }
.theme-switch.theme-on .track{ color: rgba(255,255,255,0.95); }
.theme-switch.theme-on .switch-knob{ transform: translateX(52px); background: #ffffff; box-shadow: 0 12px 30px rgba(13,71,161,0.12); }

/* dark-mode knob tweak: make knob slightly toned so no stark white look near dark edges */
body.dark .theme-switch .switch-knob{ background: linear-gradient(180deg,#f6f6f8,#eceef0); }
body.dark .theme-switch.theme-on .switch-knob{ background: linear-gradient(180deg,#ffffff,#f8faff); }

/* summary + stats */
#summary{ margin-top:12px; display:none; transform:translateY(8px); transition:opacity var(--spring-duration) var(--spring-ease), transform var(--spring-duration) var(--spring-ease); opacity:0; }
#summary.show{ display:block; opacity:1; transform:translateY(0); }
.meta-row{ display:flex; gap:12px; flex-wrap:wrap; margin-top:12px; }
.stat{ background: rgba(var(--card-bg),0.96); padding:10px 12px; border-radius:10px; box-shadow:var(--shadow-1); min-width:120px; color: rgb(var(--on-surface)); }
body.dark .stat{ background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02)); }

/* frames grid */
.frames{ display:grid; grid-template-columns: repeat(auto-fill, minmax(250px,1fr)); gap:16px; margin-top:16px; max-height:56vh; overflow:auto; padding-right:6px; }
.frame-card{
  background: linear-gradient(180deg, rgba(var(--card-bg),0.98), rgba(var(--glass-bg),1));
  padding:12px; border-radius:12px; box-shadow: 0 6px 20px rgba(16,24,40,0.06);
  display:flex; gap:12px; align-items:center; min-width:0;
  opacity:0; transform:translateY(16px) rotateX(3deg) translateZ(-6px);
  transition: opacity var(--spring-duration) var(--spring-ease), transform var(--spring-duration) var(--spring-ease), box-shadow var(--spring-duration) var(--spring-ease), background-color 320ms;
  transform-style: preserve-3d;
}
.frame-card.show{ opacity:1; transform:translateY(0) rotateX(0) translateZ(0); box-shadow:0 14px 36px rgba(16,24,40,0.08); }

/* =========
   SIMPLE HOVER FOR FRAME CARDS (instead of 3D)
   ========= */
.frame-card.simple-hover{ transition: transform 260ms var(--spring-ease), box-shadow 260ms var(--spring-ease), opacity var(--spring-duration) var(--spring-ease); }
.frame-card.simple-hover:hover{ transform: translateY(var(--frame-hover-translateY)); box-shadow: var(--frame-hover-shadow); }

/* dark tweaks for frame cards */
body.dark .frame-card{ background: linear-gradient(180deg, rgba(28,28,28,1), rgba(32,32,32,1)); border:1px solid rgba(255,255,255,0.02); }

/* preview */
.preview{ width:72px; height:72px; border-radius:10px; display:grid; place-items:center; background: linear-gradient(180deg, rgba(var(--card-bg),1), rgba(var(--glass-bg),1)); border:1px solid var(--contrast-low); flex:0 0 72px; transform-style:preserve-3d; overflow:hidden; }
.preview img{ border-radius:8px; max-width:100%; max-height:100%; display:block; transition: transform 360ms var(--spring-ease); }
.frame-info{ flex:1; min-width:0; }
.frame-info h4{ margin:0 0 6px 0; font-size:15px; color: rgb(var(--on-surface)); }
.frame-row{ display:flex; gap:8px; flex-wrap:wrap; }
.badge{ font-size:13px; padding:6px 8px; border-radius:8px; background:rgba(0,0,0,0.04); color: rgb(var(--on-surface)); }
body.dark .badge{ background: rgba(255,255,255,0.03); color: rgb(var(--on-surface)); }

/* details */
.details{ max-height:0; overflow:hidden; transition:max-height var(--spring-duration) var(--spring-ease), opacity var(--spring-duration) var(--spring-ease); opacity:0; padding:0; white-space:pre-wrap; word-break:break-word; color: rgb(var(--on-surface)); }
.details.open{ max-height: calc(70vh); opacity:1; padding-top:10px; overflow:auto; }

/* download btn */
.download-btn{
  border:1px dashed rgba(16,24,40,0.08); padding:8px 10px; border-radius:8px; text-decoration:none;
  display:inline-flex; align-items:center; gap:8px; transition: transform 320ms var(--spring-ease), box-shadow 320ms var(--spring-ease);
  background: transparent; color: inherit; font-weight:700; transform-style:preserve-3d;
}
.download-btn:active{ transform: scale(0.98); }
body.dark .download-btn{ border:1px dashed rgba(255,255,255,0.06); }

/* toast */
.toast{ position:fixed; left:20px; top:20px; min-width:280px; max-width:420px; z-index:9999; transform: translateY(-10px) scale(0.98); opacity:0; pointer-events:none; transition:transform var(--spring-duration) var(--spring-ease), opacity var(--spring-duration) var(--spring-ease); }
.toast.show{ transform: translateY(0) scale(1); opacity:1; pointer-events:auto; }
.toast .card{ padding:12px 14px; border-radius:12px; box-shadow:0 12px 30px rgba(16,24,40,0.08); background:linear-gradient(180deg, rgba(var(--card-bg),0.98), rgba(var(--glass-bg),1)); color: rgb(var(--on-surface)); }

/* modal: much more glassy as requested */
.modal-overlay{ position:fixed; inset:0; background:rgba(0,0,0,0.18); display:flex; align-items:center; justify-content:center; z-index:9998; opacity:0; pointer-events:none; transition:opacity 360ms; }
.modal-overlay.show{ opacity:1; pointer-events:auto; }

/* make modal extremely glassy while keeping text contrast readable */
.modal{
  width:92%; max-width:760px; border-radius:16px; padding:18px;
  /* much more transparent glassy layer */
  background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.02));
  border: 1px solid rgba(255,255,255,0.06);
  box-shadow:0 40px 80px rgba(13,71,161,0.10);
  transform: translateY(12px) scale(0.98) translateZ(-8px); opacity:0;
  transition: transform var(--spring-duration) var(--spring-ease), opacity var(--spring-duration) var(--spring-ease);
  color: rgb(var(--on-surface));
  /* stronger, deeper blur + saturation for pronounced glass feel */
  backdrop-filter: blur(28px) saturate(140%);
  -webkit-backdrop-filter: blur(28px) saturate(140%);
}

/* tweak modal in dark mode to remain glassy but dark */
body.dark .modal{
  background: linear-gradient(180deg, rgba(30,30,30,0.18), rgba(22,22,22,0.10));
  border: 1px solid rgba(255,255,255,0.04);
  color: rgb(var(--on-surface));
}
.modal.show{ transform: translateY(0) scale(1) translateZ(0); opacity:1; }

/* small screens: modal full width & stacking */
@media (max-width:900px){
  .container{ padding:12px; }
  .frames{ grid-template-columns: repeat(auto-fill,minmax(200px,1fr)); }
  .preview{ width:56px; height:56px; flex:0 0 56px; }
  .actions{ width:100%; }
  .uploader{ flex-direction:column; align-items:stretch; }
  .drop{ width:100%; }
  .modal{ width:calc(100% - 24px); max-width:calc(100% - 24px); padding:14px; border-radius:12px; }
  .frames{ max-height:46vh; }
}

/* keep 3D hover for other elements, but NOT for frame cards (they have simple-hover) */
.hover-3d { will-change: transform, box-shadow; transform-style:preserve-3d; }

/* small utility */
.hidden{ display:none !important; }
</style>
</head>
<body>
  <div class="container">
    <header class="appbar">
      <div class="brand">
        <div class="logo hover-3d" aria-hidden="true"><img src="image/logo-ico.svg" alt="ICO Logo" style="width:100%;height:100%;object-fit:contain"></div>
        <div>
          <div class="title">ICOProperties بتا</div>
          <div class="subtitle">آنالیز عمیق فایل‌های تصویری و .ico — پردازش کامل سمت کاربر</div>
        </div>
      </div>

      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn ghost hover-3d" id="how" title="راهنما"><span class="material-icons-outlined icon">info</span>راهنما</button>

        <div class="theme-wrapper" title="تغییر تم">
          <input id="themeToggle" class="theme-switch-checkbox" type="checkbox" aria-label="تغییر تم" />
          <!-- redesigned switch (markup preserved for JS) -->
          <label for="themeToggle" id="themeSwitch" class="theme-switch hover-3d" role="switch" aria-checked="false" tabindex="0" aria-live="polite">
            <div class="track" aria-hidden="true">
              <span class="material-icons-outlined icon icon-sun">light_mode</span>
              <span class="material-icons-outlined icon icon-moon">dark_mode</span>
            </div>
            <span class="switch-knob" aria-hidden="true"></span>
          </label>
        </div>
      </div>
    </header>

    <section class="glass" aria-label="Upload and analysis">
      <div class="uploader">
        <div class="drop hover-3d" id="drop" tabindex="0" aria-label="drop area — کلیک یا کشیدن فایل">
          <div class="big">کشیدن و رها کردن یا کلیک برای انتخاب فایل</div>
          <div class="muted">پشتیبانی: ico, png, jpg, jpeg, webp, avif, bmp, gif, tiff, svg, raw, cr2, nef, arw, dng و ...</div>
          <input id="file" type="file"
            accept=".ico,image/vnd.microsoft.icon,.png,.jpg,.jpeg,.webp,.avif,.bmp,.gif,.tif,.tiff,.svg,.raw,.cr2,.nef,.arw,.dng"
            aria-label="انتخاب فایل برای آنالیز" />
        </div>

        <div class="actions" aria-hidden="false">
          <button class="btn ghost hover-3d" id="btnClear" title="پاک کردن لیست"><span class="material-icons-outlined icon">delete</span>پاک کردن</button>
          <div style="margin-top:6px;font-size:13px;color:rgba(var(--on-surface),var(--muted-alpha))">
            برخی فرمت‌های بسیار قدیمی یا خام ممکن است پیش‌نمایش نداشته باشند؛ اما متادیتا استخراج خواهد شد.
          </div>
        </div>
      </div>

      <div id="summary">
        <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
          <div>
            <div style="font-weight:700">خلاصهٔ فایل</div>
            <div style="color:rgba(var(--on-surface),var(--muted-alpha));font-size:13px">اطلاعات کلی، پیش‌نمایش و جزییات کامل</div>
          </div>
          <div class="meta-row">
            <div class="stat"><div class="num" id="count">1</div><div class="muted">فایل</div></div>
            <div class="stat"><div class="num" id="filesize">0 بایت</div><div class="muted">حجم فایل</div></div>
            <div class="stat"><div class="num" id="formats">—</div><div class="muted">نوع تشخیص‌داده‌شده</div></div>
          </div>
        </div>

        <div class="frames" id="frames" role="list"></div>
      </div>

      <div id="notfound" style="margin-top:12px; display:none">
        <div style="font-weight:700">هیچ داده‌ای یافت نشد</div>
        <div class="muted">فایل معتبر به نظر نمی‌رسد یا چیزی برای استخراج وجود ندارد.</div>
      </div>
    </section>
  </div>

  <div id="toast" class="toast" aria-live="polite"></div>

  <div id="modalOverlay" class="modal-overlay" aria-hidden="true" role="dialog" aria-modal="true">
    <div id="helpModal" class="modal" role="document" aria-labelledby="helpTitle" tabindex="-1">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;margin-bottom:8px">
        <div>
          <div id="helpTitle" style="font-weight:700">راهنما</div>
          <div style="color:rgba(var(--on-surface),var(--muted-alpha));font-size:13px">نحوه استفاده از نسخهٔ پیشرفته</div>
        </div>
        <button id="closeHelp" class="btn ghost hover-3d" title="بستن"><span class="material-icons-outlined icon">close</span>بستن</button>
      </div>
      <div style="font-size:13px;line-height:1.8">
        - فایل را بکشید داخل کادر یا روی کادر کلیک کنید تا انتخاب شود. همهٔ پردازش‌ها کاملاً داخل مرورگر شما انجام می‌شود و هیچ فایلی به سرور ارسال نمی‌گردد.<br><br>

        - تصاویر رایج (PNG, JPEG, WEBP, GIF, AVIF و...) : پیش‌نمایش، ابعاد واقعی، bit depth (در صورت وجود)، و EXIF (برای JPEG) نمایش داده می‌شوند. اگر فایل چندفریمه باشد (مثل animated GIF یا ICO چندسایزی)، هر فریم مجزا نشان داده می‌شود تا بتوانید آنها را جدا دانلود کنید.<br><br>

        - فایل‌های ICO: هر ورودی داخل فایل (هر فریم/اندازه) استخراج می‌شود. اگر داخل آی‌سی‌او از PNG استفاده شده باشد، PNG را مستقیم نشان می‌دهیم؛ در غیر این‌صورت DIB به BMP تبدیل می‌شود تا پیش‌نمایش و دانلود ممکن باشد. اطلاعات دقیق‌تری مثل bitCount، palette و offset هر آیتم هم نمایش داده می‌شود.<br><br>

        - فرمت‌های RAW یا فرمت‌های تخصصی: بسیاری از فایل‌های خام دوربین پیش‌نمایش ندارند؛ در این حالات هدر (hex) و متادیتای در دسترس استخراج می‌شود تا در ابزارهای تخصصی بررسی کنید. فایل اصلی قابل دانلود است تا در نرم‌افزارهایی مثل RawTherapee یا Adobe Camera Raw باز شود.<br><br>

        - خطاها و فایل‌های خراب: اگر فرمت غیرقابل‌پشتیبانی یا خراب تشخیص داده شود، هِدر هگز و پیغام خطا نمایش داده می‌شود تا امکان تحلیل دستی فراهم شود. درصورتی که نیاز به کمک بیشتر داشته باشید، می‌توانید هِدر یا متن خطا را برای من بفرستی تا راهنمایی دقیق‌تر بدهم — اما توجه کن که فایل‌ها هرگز از دستگاهت خارج نمیشن مگر خودت دانلود و ارسال کنی.<br><br>
      </div>
    </div>
  </div>

<script>
/* ---------- existing JS (kept behavior intact) ---------- */
/* Utility + file parsing + UI interactions same as previous version.
   Only note: frame cards are created with 'simple-hover' class so they get simple hover.
   Theme switch logic remains identical (IDs preserved). */

const KB = 1024;
function humanSize(n){ if(n < KB) return n + ' بایت'; if(n < KB*KB) return (n/KB).toFixed(1) + ' کیلوبایت'; if(n < KB*KB*KB) return (n/KB/KB).toFixed(2) + ' مگابایت'; return (n/KB/KB/KB).toFixed(2) + ' گیگابایت'; }
function hexSlice(u8, len = 32){ return Array.from(u8.slice(0, Math.min(len,u8.length))).map(b => b.toString(16).padStart(2,'0')).join(' '); }
function readString(u8, off, len){ return String.fromCharCode.apply(null, Array.from(u8.slice(off, off+len))).replace(/\0/g,''); }

const drop = document.getElementById('drop');
const fileInput = document.getElementById('file');
const btnClear = document.getElementById('btnClear');
const howBtn = document.getElementById('how');
const summary = document.getElementById('summary');
const framesEl = document.getElementById('frames');
const countEl = document.getElementById('count');
const fileSizeEl = document.getElementById('filesize');
const formatsEl = document.getElementById('formats');
const notfound = document.getElementById('notfound');
const toast = document.getElementById('toast');
const modalOverlay = document.getElementById('modalOverlay');
const helpModal = document.getElementById('helpModal');
const closeHelp = document.getElementById('closeHelp');
const themeToggle = document.getElementById('themeToggle');
const themeSwitchBtn = document.getElementById('themeSwitch');

let createdURLs = [];

function u8(arr, off){ return arr[off]; }
function u16(arr, off, little=true){ return little ? (arr[off] | (arr[off+1]<<8)) : ((arr[off]<<8) | (arr[off+1])); }
function u32(arr, off, little=true){ if(little) return (arr[off]) | (arr[off+1]<<8) | (arr[off+2]<<16) | (arr[off+3]<<24); else return (arr[off]<<24) | (arr[off+1]<<16) | (arr[off+2]<<8) | arr[off+3]; }

function detectFormat(slice, fileName){
  if(!slice || slice.length < 12) return { format:'unknown' };
  if(slice[0]===0x89 && slice[1]===0x50 && slice[2]===0x4E && slice[3]===0x47) return {format:'PNG'};
  if(slice[0]===0xFF && slice[1]===0xD8) return {format:'JPEG'};
  if(slice[0]===0x47 && slice[1]===0x49 && slice[2]===0x46) return {format:'GIF'};
  if(readString(slice,0,4) === 'RIFF' && readString(slice,8,4) === 'WEBP') return {format:'WEBP'};
  const sftyp = readString(slice,4,4);
  if(sftyp === 'ftyp'){
    const brands = readString(slice,8,8);
    if(brands.includes('avif') || brands.includes('avis')) return {format:'AVIF'};
    if(brands.includes('heic') || brands.includes('mif1')) return {format:'HEIF'};
  }
  if(slice[0]===0x42 && slice[1]===0x4D) return {format: 'BMP'};
  if((slice[0]===0x49 && slice[1]===0x49 && slice[2]===0x2A && slice[3]===0x00) || (slice[0]===0x4D && slice[1]===0x4D && slice[2]===0x00 && slice[3]===0x2A)) return {format:'TIFF'};
  if(slice[0]===0x3C && readString(slice,1,4).toLowerCase().includes('svg')) return {format:'SVG'};
  const res = u16(slice,0,true);
  const typ = u16(slice,2,true);
  if(res === 0 && (typ ===1 || typ === 2)) return {format:'ICO'};
  const ext = (fileName||'').split('.').pop()?.toLowerCase();
  const rawExts = ['raw','cr2','nef','arw','dng','raf','rw2','orf'];
  if(rawExts.includes(ext)) return {format:'RAW', ext};
  if(ext === 'ico') return {format:'ICO'};
  if(['jpg','jpeg','png','gif','bmp','webp','svg','tif','tiff','avif'].includes(ext)) return {format: ext.toUpperCase()};
  return {format:'unknown', ext};
}

/* parse helpers (same as before) */
function parsePNG(slice){
  try{
    const dv = new DataView(slice.buffer, slice.byteOffset, slice.byteLength);
    let off = 8;
    while(off + 8 < slice.length){
      const len = dv.getUint32(off, false);
      const type = readString(slice, off+4,4);
      if(type === 'IHDR'){
        const width = dv.getUint32(off+8, false);
        const height = dv.getUint32(off+12, false);
        const bitDepth = dv.getUint8(off+16);
        const colorType = dv.getUint8(off+17);
        return { width, height, bitDepth, colorType };
      }
      off += 8 + len + 4;
    }
  }catch(e){}
  return null;
}

function parseJPEGExif(slice){
  try{
    const dv = new DataView(slice.buffer, slice.byteOffset, slice.byteLength);
    let off = 2;
    while(off < slice.length){
      if(slice[off] !== 0xFF) break;
      const marker = slice[off+1];
      const len = dv.getUint16(off+2,false);
      if(marker === 0xE1){
        const exifHeader = readString(slice, off+4, 6);
        if(!exifHeader.startsWith('Exif')) { off += 2 + len; continue; }
        const tiffStart = off + 10;
        const endianStr = readString(slice, tiffStart, 2);
        const little = endianStr === 'II';
        const tiffDv = new DataView(slice.buffer, slice.byteOffset + tiffStart, slice.byteLength - (tiffStart));
        const firstIFDOffset = (little ? tiffDv.getUint32(4, true) : tiffDv.getUint32(4, false));
        const readIFD = (ifdOffset)=>{
          const tags = {};
          const entries = little ? tiffDv.getUint16(ifdOffset, true) : tiffDv.getUint16(ifdOffset, false);
          let p = ifdOffset + 2;
          for(let i=0;i<entries;i++){
            const tag = little ? tiffDv.getUint16(p, true) : tiffDv.getUint16(p, false);
            const type = little ? tiffDv.getUint16(p+2, true) : tiffDv.getUint16(p+2, false);
            const count = little ? tiffDv.getUint32(p+4, true) : tiffDv.getUint32(p+4, false);
            const valueOff = little ? tiffDv.getUint32(p+8, true) : tiffDv.getUint32(p+8, false);
            let val = null;
            try{
              if(type === 2){
                const strOff = valueOff;
                let s = '';
                for(let k=0;k<count;k++){
                  const ch = tiffDv.getUint8(strOff + k);
                  if(!ch) break;
                  s += String.fromCharCode(ch);
                }
                val = s;
              } else { val = valueOff; }
            }catch(e){}
            tags[tag] = val;
            p += 12;
          }
          return tags;
        };
        const tags = readIFD(firstIFDOffset);
        const map = {};
        if(tags[271]) map.Make = tags[271];
        if(tags[272]) map.Model = tags[272];
        if(tags[306]) map.DateTime = tags[306];
        return map;
      } else { off += 2 + len; }
    }
  }catch(e){}
  return {};
}

function parseICO(bytes){
  if(bytes.length < 6) throw new Error('invalid');
  const reserved = u16(bytes,0,true);
  const type = u16(bytes,2,true);
  const count = u16(bytes,4,true);
  if(reserved !== 0 || (type !== 1 && type !== 2) || count < 1) throw new Error('invalid ico');
  const entries = [];
  let off = 6;
  for(let i=0;i<count;i++){
    const width = u8(bytes, off) || 256;
    const height = u8(bytes, off+1) || 256;
    const colorCount = u8(bytes, off+2);
    const planes = u16(bytes, off+4, true);
    const bitCount = u16(bytes, off+6, true);
    const bytesInRes = u32(bytes, off+8, true);
    const imageOffset = u32(bytes, off+12, true);
    entries.push({ width, height, colorCount, planes, bitCount, bytesInRes, imageOffset });
    off += 16;
  }
  return { entries, bytes };
}

function convertDIBSliceToBMPBlob(sliceUint8) {
  const sliceDV = new DataView(sliceUint8.buffer, sliceUint8.byteOffset, sliceUint8.byteLength);
  const biSize = sliceDV.getUint32(0, true);
  if (sliceUint8.length < 16 || biSize < 12) {
    const header = new Uint8Array(14);
    header.set([0x42,0x4D],0);
    const bfSize = 14 + sliceUint8.length;
    const bfSizeBytes = new Uint8Array([bfSize & 0xFF, (bfSize>>8)&0xFF, (bfSize>>16)&0xFF, (bfSize>>24)&0xFF]);
    header.set(bfSizeBytes,2);
    header.set([0,0,0,0],6);
    const bfOffBits = 14 + biSize;
    const bfOffBytes = new Uint8Array([bfOffBits & 0xFF, (bfOffBits>>8)&0xFF, (bfOffBits>>16)&0xFF, (bfOffBits>>24)&0xFF]);
    header.set(bfOffBytes,10);
    return { blob: new Blob([header.buffer, sliceUint8.buffer], { type: 'image/bmp' }), bitCount: 32, width: null, height: null, xorSize: 0, paletteCount: 0 };
  }
  const width = sliceDV.getInt32(4, true);
  const heightRaw = sliceDV.getInt32(8, true);
  const bitCount = sliceDV.getUint16(14, true);
  const absHeightRaw = Math.abs(heightRaw);
  const trueHeight = Math.trunc(absHeightRaw / 2);
  const signedTrueHeight = heightRaw < 0 ? -trueHeight : trueHeight;
  const rowSize = Math.floor((bitCount * width + 31) / 32) * 4;
  const xorSize = rowSize * trueHeight;
  let paletteBytes = 0;
  let paletteCount = 0;
  let biClrUsed = 0;
  if(biSize >= 40 && sliceUint8.length >= 36){
    biClrUsed = sliceDV.getUint32(32, true);
  }
  if (bitCount <= 8) {
    const paletteEntries = (biClrUsed && biClrUsed > 0) ? biClrUsed : (1 << bitCount);
    paletteCount = paletteEntries;
    paletteBytes = paletteEntries * 4;
  }
  const pixelArrayOffset = biSize + paletteBytes;
  const expectedMin = pixelArrayOffset + xorSize;
  const newSliceLength = Math.min(sliceUint8.length, expectedMin);
  const dibTrimmed = sliceUint8.slice(0, newSliceLength);
  const dvNew = new DataView(dibTrimmed.buffer, dibTrimmed.byteOffset, dibTrimmed.byteLength);
  dvNew.setInt32(8, signedTrueHeight, true);
  const header = new Uint8Array(14);
  header.set([0x42,0x4D],0);
  const bfSize = 14 + dibTrimmed.length;
  const bfSizeBytes = new Uint8Array([bfSize & 0xFF, (bfSize>>8)&0xFF, (bfSize>>16)&0xFF, (bfSize>>24)&0xFF]);
  header.set(bfSizeBytes,2);
  header.set([0,0,0,0],6);
  const bfOffBits = 14 + biSize;
  const bfOffBytes = new Uint8Array([bfOffBits & 0xFF, (bfOffBits>>8)&0xFF, (bfOffBits>>16)&0xFF, (bfOffBits>>24)&0xFF]);
  header.set(bfOffBytes,10);
  return { blob: new Blob([header.buffer, dibTrimmed.buffer], { type: 'image/bmp' }), bitCount, width, height: signedTrueHeight, xorSize, paletteCount };
}

/* UI interactions (drag/drop, file handling) */
drop.addEventListener('click', (e)=> { if(e.target.id !== 'file') fileInput.click(); });
drop.addEventListener('keydown', (e)=> { if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); fileInput.click(); } });
['dragenter','dragover'].forEach(ev=>{ drop.addEventListener(ev, (e)=>{ e.preventDefault(); drop.classList.add('dragover'); }); });
['dragleave','drop'].forEach(ev=>{ drop.addEventListener(ev, (e)=>{ drop.classList.remove('dragover'); }); });
drop.addEventListener('drop', (e)=>{ e.preventDefault(); const f = e.dataTransfer.files?.[0]; if(f) handleFilesWithClear([f]); });
howBtn.addEventListener('click', ()=> openHelp());
fileInput.addEventListener('change', (e)=>{ if(e.target.files && e.target.files.length) { handleFilesWithClear(e.target.files); } });
btnClear.addEventListener('click', async ()=>{ await animateRemoveFrames(); resetSummary(); revokeAll(); fileInput.value = ''; });
function revokeAll(){ createdURLs.forEach(u=>{ try{ URL.revokeObjectURL(u); }catch(_){ } }); createdURLs = []; }
function resetSummary(){ summary.classList.remove('show'); summary.style.display = 'none'; notfound.style.display = 'none'; countEl.textContent = '0'; fileSizeEl.textContent = '0 بایت'; formatsEl.textContent = '—'; framesEl.innerHTML = ''; }
function animateRemoveFrames(){ return new Promise((resolve)=>{ const cards = Array.from(framesEl.querySelectorAll('.frame-card')); if(cards.length === 0){ resolve(); return; } cards.forEach((c,i)=>{ setTimeout(()=>{ c.classList.remove('show'); }, i * 90); }); const total = 600 + (cards.length * 90); setTimeout(()=>{ framesEl.innerHTML = ''; resolve(); }, total); }); }
async function handleFilesWithClear(files){ await animateRemoveFrames(); resetSummary(); if(files && files.length) { await handleFiles(files); } }
async function handleFiles(files){ const file = files[0]; if(!file) return; const ab = await file.arrayBuffer(); const bytes = new Uint8Array(ab); try{ const det = detectFormat(bytes, file.name); if(det.format === 'ICO'){ const icoRes = parseICO(bytes); await renderICO(icoRes, file); } else { await renderGeneric(bytes, file, det); } }catch(err){ console.error(err); resetSummary(); showNotFound(); } }

/* rendering functions: note -> created cards use 'simple-hover' class so they get the simple hover style */
async function renderICO(res, file){
  framesEl.innerHTML = '';
  notfound.style.display = 'none';
  summary.style.display = 'block';
  requestAnimationFrame(()=> summary.classList.add('show'));
  countEl.textContent = res.entries.length;
  fileSizeEl.textContent = humanSize(file.size);
  const foundFormats = new Set();
  for(let i=0;i<res.entries.length;i++){
    const e = res.entries[i];
    const slice = res.bytes.slice(e.imageOffset, e.imageOffset + e.bytesInRes);
    const isPng = slice[0] === 0x89 && slice[1] === 0x50 && slice[2] === 0x4E && slice[3] === 0x47;
    let blob, format;
    if(isPng){
      blob = new Blob([slice.buffer], { type: 'image/png' });
      format = 'PNG';
      e.bitsPerPixel = 32;
      try{ const p = parsePNG(slice); if(p) { e.pngInfo = p; } }catch(_){}
    } else {
      try {
        const conv = convertDIBSliceToBMPBlob(slice);
        if (conv && conv.blob) {
          blob = conv.blob;
          format = 'BMP (DIB)';
          e.bitsPerPixel = conv.bitCount || e.bitCount || 32;
          e.paletteCount = conv.paletteCount || 0;
        } else {
          const header = new Uint8Array(14);
          header.set([0x42,0x4D],0);
          const bfSize = 14 + slice.length;
          const bfSizeBytes = new Uint8Array([bfSize & 0xFF, (bfSize>>8)&0xFF, (bfSize>>16)&0xFF, (bfSize>>24)&0xFF]);
          header.set(bfSizeBytes,2);
          const blobTmp = new Blob([header.buffer, slice.buffer], { type: 'image/bmp' });
          blob = blobTmp; format = 'BMP (DIB)'; e.bitsPerPixel = e.bitCount || 32;
          try{ e.paletteCount = (e.bitCount && e.bitCount <= 8) ? (1 << e.bitCount) : 0; }catch(_){ e.paletteCount = 0; }
        }
      } catch (err) {
        const header = new Uint8Array(14);
        header.set([0x42,0x4D],0);
        const bfSize = 14 + slice.length;
        const bfSizeBytes = new Uint8Array([bfSize & 0xFF, (bfSize>>8)&0xFF, (bfSize>>16)&0xFF, (bfSize>>24)&0xFF]);
        header.set(bfSizeBytes,2);
        const blobTmp = new Blob([header.buffer, slice.buffer], { type: 'image/bmp' });
        blob = blobTmp; format = 'BMP (DIB)'; e.bitsPerPixel = e.bitCount || 32;
      }
    }
    foundFormats.add(format);
    const url = URL.createObjectURL(blob);
    createdURLs.push(url);
    const img = await loadImage(url);
    const canvas = document.createElement('canvas'); canvas.width = img.naturalWidth || e.width || 1; canvas.height = img.naturalHeight || Math.abs(e.height) || 1;
    const ctx = canvas.getContext('2d'); try{ ctx.drawImage(img,0,0); }catch(e){}
    let hasAlpha = false;
    try{
      const data = ctx.getImageData(0,0,Math.min(64,canvas.width), Math.min(64,canvas.height)).data;
      for(let p=3;p<data.length;p+=4){ if(data[p] !== 255){ hasAlpha = true; break; } }
    }catch(e){}
    const actualDimensions = (img.naturalWidth || e.width) + '×' + (img.naturalHeight || e.height);
    const human = humanSize(e.bytesInRes);
    const headerHex = hexSlice(slice, 48);
    const card = document.createElement('div');
    card.className = 'frame-card simple-hover';
    card.innerHTML = `
      <div class="preview hover-3d" role="img" aria-label="preview frame ${i+1}"><img src="${url}" alt="frame-${i}"></div>
      <div class="frame-info">
        <h4>فریم ${i+1} — ${actualDimensions}</h4>
        <div class="frame-row">
          <div class="badge">فرمت: ${format}</div>
          <div class="badge">اعلان عرض/ارتفاع: ${e.width}×${e.height}</div>
          <div class="badge">عمق رنگ (ثبت‌شده): ${e.bitCount || '—'} بیت</div>
          <div class="badge">عمق رنگ (محاسبه‌شده): ${e.bitsPerPixel ?? '—'} بیت</div>
          <div class="badge">پالت: ${(typeof e.paletteCount === 'number' ? e.paletteCount : e.colorCount ?? '—')}</div>
          <div class="badge">آلفا: ${hasAlpha ? 'دارد' : 'ندارد'}</div>
          <div class="badge">حجم: ${human}</div>
          <div class="badge">اندیس: offset ${e.imageOffset}</div>
        </div>
        <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <a class="download-btn" href="${url}" download="icon-frame-${i+1}.${format.startsWith('PNG')? 'png': 'bmp'}"><span class="material-icons-outlined">download</span>دانلود</a>
          <button class="btn copy-meta-btn" data-meta='${escapeHtml(JSON.stringify({
            index: i+1,
            width: e.width, height: e.height, declaredBitCount: e.bitCount, bitsPerPixel: e.bitsPerPixel, palette: e.paletteCount||e.colorCount||0, planes: e.planes, bytesInRes: e.bytesInRes, format, hasAlpha
          }))}'><span class="material-icons-outlined">content_copy</span>کپی مشخصات</button>
          <button class="btn details-btn" data-details='${escapeHtml(headerHex)}'><span class="material-icons-outlined">expand_more</span>جزئیات</button>
        </div>
        <div class="details" aria-hidden="true"><div class="inner">Header (hex): ${headerHex}</div></div>
      </div>
    `;
    framesEl.appendChild(card);
    requestAnimationFrame(()=> setTimeout(()=> card.classList.add('show'), i * 90));
  }
  formatsEl.textContent = Array.from(foundFormats).join(' ، ');
}

async function renderGeneric(bytes, file, det){
  framesEl.innerHTML = '';
  notfound.style.display = 'none';
  summary.style.display = 'block';
  requestAnimationFrame(()=> summary.classList.add('show'));
  countEl.textContent = '1';
  fileSizeEl.textContent = humanSize(file.size);
  const foundFormats = new Set();

  const slice = bytes.slice(0, 128);
  const info = detectFormat(bytes, file.name);
  let format = info.format || 'unknown';
  foundFormats.add(format);
  const meta = { name: file.name, size: file.size, lastModified: file.lastModified, format };

  if(format === 'PNG'){
    const pngInfo = parsePNG(bytes);
    if(pngInfo){ meta.width = pngInfo.width; meta.height = pngInfo.height; meta.bitDepth = pngInfo.bitDepth; meta.colorType = pngInfo.colorType; }
  }
  let exif = {};
  if(format === 'JPEG'){
    exif = parseJPEGExif(bytes);
    if(Object.keys(exif).length) meta.exif = exif;
  }
  let blob = null;
  try{
    if(format === 'BMP' || (format === 'unknown' && readString(slice,0,2) === 'BM')){
      blob = new Blob([bytes.buffer], { type: 'image/bmp' });
    } else if(format === 'TIFF'){
      blob = new Blob([bytes.buffer], { type: 'image/tiff' });
    } else if(format === 'SVG'){
      blob = new Blob([bytes.buffer], { type: 'image/svg+xml' });
    } else if(['JPEG','PNG','GIF','WEBP','AVIF','HEIF'].includes(format)){
      const mimeMap = { PNG:'image/png', JPEG:'image/jpeg', GIF:'image/gif', WEBP:'image/webp', AVIF:'image/avif' };
      blob = new Blob([bytes.buffer], { type: mimeMap[format] || '' });
    } else if(format === 'RAW'){
      blob = new Blob([bytes.buffer], { type: 'application/octet-stream' });
    } else {
      blob = new Blob([bytes.buffer], { type: file.type || 'application/octet-stream' });
    }
  }catch(e){
    blob = new Blob([bytes.buffer], { type: file.type || 'application/octet-stream' });
  }

  const canPreview = blob && (blob.type.startsWith('image/') || blob.type === 'image/svg+xml');
  let url = null;
  if(canPreview){
    url = URL.createObjectURL(blob);
    createdURLs.push(url);
    const img = await loadImage(url);
    if(img && (img.naturalWidth || img.naturalHeight)){
      meta.width = img.naturalWidth;
      meta.height = img.naturalHeight;
    }
  } else {
    url = URL.createObjectURL(blob);
    createdURLs.push(url);
  }

  const headerHex = hexSlice(bytes, 64);
  const card = document.createElement('div');
  card.className = 'frame-card simple-hover';
  card.innerHTML = `
    <div class="preview hover-3d">${ url ? `<img src="${url}" alt="preview">` : '<div style="font-size:12px;color:rgba(0,0,0,0.45)">بدون پیش‌نمایش</div>' }</div>
    <div class="frame-info">
      <h4>${escapeHtml(file.name)}</h4>
      <div style="font-size:13px;color:rgba(var(--on-surface),0.68)">نوع: ${format} • حجم: ${humanSize(file.size)}</div>
      <div class="frame-row" style="margin-top:8px">
        <div class="badge">نام فایل: ${escapeHtml(file.name)}</div>
        <div class="badge">حجم: ${humanSize(file.size)}</div>
        <div class="badge">آخرین تغییر: ${new Date(file.lastModified).toLocaleString()}</div>
        <div class="badge">فرمت تشخیص: ${format}</div>
        <div class="badge">ابعاد: ${meta.width ? (meta.width + '×' + (meta.height||'—')) : '—'}</div>
        <div class="badge">bitDepth: ${meta.bitDepth ?? '—'}</div>
      </div>
      <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <a class="download-btn" href="${url}" download="${file.name}"><span class="material-icons-outlined">download</span>دانلود</a>
        <button class="btn copy-meta-btn" data-meta='${escapeHtml(JSON.stringify({
          name: file.name, size: file.size, lastModified: new Date(file.lastModified).toISOString(), format, width: meta.width||null, height: meta.height||null, bitDepth: meta.bitDepth||null, exif: meta.exif||null
        }))}'><span class="material-icons-outlined">content_copy</span>کپی مشخصات</button>
        <button class="btn details-btn" data-details='${escapeHtml(headerHex)}'><span class="material-icons-outlined">expand_more</span>جزئیات</button>
      </div>
      <div class="details" aria-hidden="true"><div class="inner">
        Header (hex): ${headerHex}
        ${meta.exif ? '\n\nEXIF: ' + JSON.stringify(meta.exif,null,2) : ''}
      </div></div>
    </div>
  `;
  framesEl.appendChild(card);
  requestAnimationFrame(()=> setTimeout(()=> card.classList.add('show'), 60));
  formatsEl.textContent = format;
}

function loadImage(src){ return new Promise((res)=>{ const img = new Image(); img.onload = ()=>res(img); img.onerror = ()=>res(img); img.src = src; }); }

framesEl.addEventListener('click', async (e) => {
  const copyBtn = e.target.closest('.copy-meta-btn');
  if(copyBtn){
    const metaString = copyBtn.getAttribute('data-meta') || '{}';
    try{
      await navigator.clipboard?.writeText(metaString);
      const prev = copyBtn.innerHTML;
      copyBtn.innerHTML = '<span class="material-icons-outlined">check</span>کپی شد ✓';
      setTimeout(()=>{ copyBtn.innerHTML = prev; }, 1200);
    }catch(err){
      showToast('کپی به کلیپ‌بورد ممکن نیست — مرورگر اجازه نداد.', 3000);
    }
    return;
  }

  const detBtn = e.target.closest('.details-btn');
  if(detBtn){
    const card = detBtn.closest('.frame-card');
    if(!card) return;
    const detailsEl = card.querySelector('.details');
    const open = detailsEl.classList.toggle('open');
    detailsEl.setAttribute('aria-hidden', String(!open));
    return;
  }
});

function openHelp(){
  modalOverlay.classList.add('show');
  helpModal.classList.add('show');
  modalOverlay.setAttribute('aria-hidden','false');
  setTimeout(()=> { closeHelp.focus?.(); helpModal.focus?.(); }, 80);
}
function closeHelpModal(){
  helpModal.classList.remove('show');
  modalOverlay.classList.remove('show');
  modalOverlay.setAttribute('aria-hidden','true');
  howBtn.focus?.();
}
closeHelp.addEventListener('click', closeHelpModal);
modalOverlay.addEventListener('click', (e)=>{ if(e.target === modalOverlay) closeHelpModal(); });
document.addEventListener('keydown', (e)=>{ if(e.key === 'Escape' && modalOverlay.classList.contains('show')) closeHelpModal(); });

function showToast(html, timeout=3200){ toast.innerHTML = `<div class="card">${html}</div>`; toast.classList.add('show'); clearTimeout(window._toastTimer); window._toastTimer = setTimeout(()=>{ toast.classList.remove('show'); }, timeout); }
function showNotFound(){ notfound.style.display = 'block'; showToast('فایل معتبر نیست یا قابل پردازش نمی‌باشد.'); }

/* theme init & controls (same IDs) */
(function initTheme(){
  const saved = localStorage.getItem('ico-theme');
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  const useDark = saved ? (saved === 'dark') : prefersDark;
  applyTheme(useDark, false);
  themeToggle.checked = useDark;
  themeSwitchBtn.setAttribute('aria-checked', String(useDark));
})();

themeToggle.addEventListener('change', (e)=>{ applyTheme(e.target.checked, true); themeSwitchBtn.setAttribute('aria-checked', String(e.target.checked)); });
themeSwitchBtn.addEventListener('click', (e)=>{ e.preventDefault(); const next = !document.body.classList.contains('dark'); applyTheme(next, true); themeToggle.checked = next; themeSwitchBtn.setAttribute('aria-checked', String(next)); });
themeSwitchBtn.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' ') { e.preventDefault(); themeSwitchBtn.click(); } });
function applyTheme(isDark, save=true){
  if(isDark) document.body.classList.add('dark'); else document.body.classList.remove('dark');
  themeSwitchBtn.classList.toggle('theme-on', isDark);
  themeToggle.checked = isDark;
  if(save) localStorage.setItem('ico-theme', isDark ? 'dark' : 'light');
}

/* hover-3d for non-frame elements kept (no 3D on frame cards) */
(function enableHover3D(){
  const supports = window.matchMedia && window.matchMedia('(hover: hover) and (pointer: fine)').matches;
  if(!supports) return;
  const activeEls = new Set();
  let raf = null;
  function onEnter(e){
    const el = e.currentTarget;
    el.dataset._hoverActive = '1';
    el.style.transition = 'transform 260ms var(--spring-ease), box-shadow 260ms var(--spring-ease)';
    activeEls.add(el);
  }
  function onMove(e){
    const el = e.currentTarget;
    if(!el.dataset._hoverActive) return;
    const rect = el.getBoundingClientRect();
    const cx = rect.left + rect.width/2;
    const cy = rect.top + rect.height/2;
    const dx = e.clientX - cx;
    const dy = e.clientY - cy;
    const nx = Math.max(-1, Math.min(1, dx / (rect.width/2)));
    const ny = Math.max(-1, Math.min(1, dy / (rect.height/2)));
    if(raf) cancelAnimationFrame(raf);
    raf = requestAnimationFrame(()=>{
      const maxRot = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hover-max-rot')) || 9;
      const rotY = (nx * maxRot).toFixed(2);
      const rotX = (-ny * maxRot).toFixed(2);
      const maxZ = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hover-max-translateZ')) || 14;
      const depth = Math.max(6, Math.round((1 - Math.max(Math.abs(nx), Math.abs(ny))) * maxZ));
      el.style.transform = `perspective(800px) translateZ(${depth}px) rotateX(${rotX}deg) rotateY(${rotY}deg)`;
      const shadowScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--hover-shadow-scale')) || 1.08;
      const baseY = 14 * shadowScale;
      const offX = Math.round(-nx * 18);
      const offY = Math.round(-ny * baseY);
      const blur = Math.round(18 + Math.abs(nx*20) + Math.abs(ny*10));
      el.style.boxShadow = `${offX}px ${offY}px ${blur}px rgba(16,24,40,0.12)`;
    });
  }
  function onLeave(e){
    const el = e.currentTarget;
    delete el.dataset._hoverActive;
    activeEls.delete(el);
    if(raf) cancelAnimationFrame(raf);
    el.style.transition = 'transform 480ms cubic-bezier(.2,.9,.25,1), box-shadow 480ms cubic-bezier(.2,.9,.25,1)';
    el.style.transform = '';
    el.style.boxShadow = '';
  }
  const attachTo = () => {
    const els = document.querySelectorAll('.hover-3d');
    els.forEach(el=>{
      if(el.__hover3d_attached) return;
      el.__hover3d_attached = true;
      el.addEventListener('pointerenter', onEnter);
      el.addEventListener('pointermove', onMove);
      el.addEventListener('pointerleave', onLeave);
      el.addEventListener('pointercancel', onLeave);
    });
  };
  attachTo();
  const mo = new MutationObserver(()=> attachTo());
  mo.observe(document.body, { childList:true, subtree:true });
})();

(function microInteractions(){
  if(window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches) return;
  const interactive = [document.querySelector('.logo'), btnClear, howBtn, themeSwitchBtn];
  interactive.forEach(el=>{
    if(!el) return;
    el.classList.add('hover-3d');
    const add = ()=> el.classList.add('pressed');
    const rem = ()=> el.classList.remove('pressed');
    el.addEventListener('pointerdown', add);
    window.addEventListener('pointerup', rem);
    el.addEventListener('keydown', (ev)=>{ if(ev.key === ' ' || ev.key === 'Enter') add(); });
    el.addEventListener('keyup', (ev)=>{ if(ev.key === ' ' || ev.key === 'Enter') rem(); });
  });
})();

function escapeHtml(s){ return String(s).replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('"','&quot;'); }
</script>
</body>
</html>
